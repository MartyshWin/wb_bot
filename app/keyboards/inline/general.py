import ast
import json
import re
import shlex
from itertools import batched
from sys import prefix
from typing import Union, Callable, List, Any, TypedDict, Optional, Iterable, Tuple, Sequence

from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
import calendar
from datetime import datetime

from aiogram.utils.keyboard import InlineKeyboardBuilder

from app.enums.constants import COEF_TITLES
from app.enums.general import BoxType
from app.schemas.general import ResponseWarehouses, ResponseBoxTypes, ResponseCoefs, ResponseTasks


# –ö–Ω–æ–ø–∫–∏ –¥–æ–ª–∂–Ω—ã –ø–æ–ª—É—á–∞—Ç—å —è–∑—ã–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, —á—Ç–æ–±—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
class InlineKeyboardHandler:
    def __init__(self):

        self.start_kb: InlineKeyboardMarkup = self.build_inline_keyboard([
            [{"text": "üìù –°–æ–∑–¥–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á", "callback_data": "create_task"}],
            [{"text": "üóÇ –ú–æ–π —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á", "callback_data": "my_tasks"}],
            [{"text": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", "callback_data": "alarm_setting"}],
            [{"text": "üíé –ü–æ–¥–ø–∏—Å–∫–∞", "callback_data": "choose_tariff"}],
            [{"text": "‚ÑπÔ∏è –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è", "callback_data": "rules"}],
        ])

        self.task_mode_keyboard: InlineKeyboardMarkup = self.build_inline_keyboard([
            [
                {"text": "üõ†Ô∏è –ú–∞—Å—Å–æ–≤–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–¥–∞—á", "callback_data": "task_mode_mass"},
                {"text": "üîß –ì–∏–±–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–¥–∞—á", "callback_data": "task_mode_flex"}
            ],
            [{"text": "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "callback_data": "main"}],
        ])
        self.tasks_update_all: InlineKeyboardMarkup = self.build_inline_keyboard([
            [{"text": "‚ôªÔ∏è –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫", "callback_data": "task_delete_confirm"}],
            [{"text": "‚úèÔ∏è –î–æ–±–∞–≤–∏—Ç—å –∫ —Å–ø–∏—Å–∫—É", "callback_data": "tasks_append"}],
            [{"text": "–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", "callback_data": "main"}],
        ])

        self.delete_confirm: InlineKeyboardMarkup = self.build_inline_keyboard([
            [{"text": "–î–∞", "callback_data": "task_delete_all"}], # tasks_update_all
            [{"text": "–û—Ç–º–µ–Ω–∞", "callback_data": "main"}],
        ])

        self.tasks_delete_all: InlineKeyboardMarkup = self.build_inline_keyboard([
            [{"text": "‚ôªÔ∏è –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫", "callback_data": "create_task"}],
            [{"text": "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "callback_data": "main"}],
        ])

        # self.search_slot_mass: InlineKeyboardMarkup = self.build_inline_keyboard([
        #     [{"text": "üöÄ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ —Ä–∞–±–æ—Ç—É", "callback_data": "task_save"}],
        #     [{"text": "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "callback_data": "main"}],
        # ])
        #
        # self.search_slot_flex: InlineKeyboardMarkup = self.build_inline_keyboard([
        #     [{"text": "üöÄ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ —Ä–∞–±–æ—Ç—É", "callback_data": "task_save"}],
        #     [{"text": "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "callback_data": "main"}],
        # ])

        self.subscribe: InlineKeyboardMarkup = self.build_inline_keyboard([
            [{"text": "üí≥ –û—Ñ–æ—Ä–º–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", "callback_data": "choose_tariff"}],
            [{"text": "üÜì –ü–æ–ª—É—á–∏—Ç—å 7 –¥–Ω–µ–π –¥–æ—Å—Ç—É–ø–∞", "callback_data": "free_sub"}],
            [{"text": "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "callback_data": "main"}],
        ])

        self.bot_add: InlineKeyboardMarkup = self.build_inline_keyboard([
            [{"text": "üö´ –û—Ç–º–µ–Ω–∞", "callback_data": "alarm_setting"}],
        ])

        self.choose_tariff: InlineKeyboardMarkup = self.build_inline_keyboard([
            [{"text": "üíº –¢–∞—Ä–∏—Ñ \"–°–¢–ê–†–¢\" (590 —Ä—É–±.)", "callback_data": "tarif_1"}],
            [{"text": "üöÄ –¢–∞—Ä–∏—Ñ \"–ü–†–û–§–ò\" (790 —Ä—É–±.)", "callback_data": "tarif_2"}],
            [{"text": "üëë –¢–∞—Ä–∏—Ñ \"–ú–ê–ö–°–ò\" (1390 —Ä—É–±.)", "callback_data": "tarif_3"}],
            [{"text": "–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", "callback_data": "choose_tariff"}],
        ])

        self.choose_tariff_with_free: InlineKeyboardMarkup = self.build_inline_keyboard([
            [{"text": "üíº –¢–∞—Ä–∏—Ñ \"–°–¢–ê–†–¢\" (590 —Ä—É–±.)", "callback_data": "tarif_1"}],
            [{"text": "üöÄ –¢–∞—Ä–∏—Ñ \"–ü–†–û–§–ò\" (790 —Ä—É–±.)", "callback_data": "tarif_2"}],
            [{"text": "üëë –¢–∞—Ä–∏—Ñ \"–ú–ê–ö–°–ò\" (1390 —Ä—É–±.)", "callback_data": "tarif_3"}],
            [{"text": "üÜì –ü–æ–ª—É—á–∏—Ç—å 7 –¥–Ω–µ–π –¥–æ—Å—Ç—É–ø–∞", "callback_data": "free_sub"}],
            [{"text": "–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", "callback_data": "choose_tariff"}],
        ])

        self.my_tasks: InlineKeyboardMarkup = self.build_inline_keyboard([
            [{"text": "üìù –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á–∏", "callback_data": "create_task"}],
            [{"text": "‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∑–∞–¥–∞—á–∏", "callback_data": "task_update"}],
            [{"text": "üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –≤—Å–µ –∑–∞–¥–∞—á–∏", "callback_data": "task_delete_confirm"}],
            [{"text": "–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", "callback_data": "main"}],
        ])

        self.alarm_setting: InlineKeyboardMarkup = self.build_inline_keyboard([
            [{"text": "üöÄ –ü–æ–¥–∫–ª—é—á–∏—Ç—å –±–æ—Ç–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", "callback_data": "bot_add"}],
            [{"text": "‚≠ê –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ —Å–∫–ª–∞–¥–∞–º", "callback_data": "alarm_edit"}],
            [{"text": "–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", "callback_data": "main"}],
        ])

        self.my_tasks_empty: InlineKeyboardMarkup = self.build_inline_keyboard([
            [{"text": "üìù –°–æ–∑–¥–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á", "callback_data": "create_task"}],
            [{"text": "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "callback_data": "main"}],
        ])

        self.select_date = self.create_select_date()

        # self.select_date: InlineKeyboardMarkup = self.create_select_date()


    # def get_keyboard(self, attribute_name: str | object) -> str | None | Any:
    #     """
    #     –ü–æ–ª—É—á–∞–µ—Ç –º–µ—Ç–æ–¥ –ø–æ –∏–º–µ–Ω–∏ –∏ –≤—ã–∑—ã–≤–∞–µ—Ç –µ–≥–æ —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏, –µ—Å–ª–∏ –æ–Ω–∏ —É–∫–∞–∑–∞–Ω—ã.
    #
    #     :param attribute_name: –ò–º—è –º–µ—Ç–æ–¥–∞ –∏ –∞—Ä–≥—É–º–µ–Ω—Ç—ã –≤ —Ñ–æ—Ä–º–∞—Ç–µ 'method_name(arg1, arg2)'.
    #     :return: –†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–µ—Ç–æ–¥–∞ –∏–ª–∏ —Å—Ç—Ä–æ–∫–∞ —Å –æ—à–∏–±–∫–æ–π, –µ—Å–ª–∏ –º–µ—Ç–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω.
    #     """
    #     # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å–∫–æ–±–∫–∏ –≤ —Å—Ç—Ä–æ–∫–µ
    #     if attribute_name is not None:
    #         if '(' in attribute_name and attribute_name.endswith(')'):
    #             # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–º—è –º–µ—Ç–æ–¥–∞ –∏ –∞—Ä–≥—É–º–µ–Ω—Ç—ã
    #             match = re.match(r"(\w+)\((.*)\)", attribute_name)
    #             if not match:
    #                 return "Invalid format"
    #
    #             method_name, args_str = match.groups()
    #
    #             # –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–æ–¥ –ø–æ –∏–º–µ–Ω–∏
    #             method = getattr(self, method_name, None)
    #             if not method or not callable(method):
    #                 return "Not Found keyboard"
    #
    #             # –†–∞–∑–¥–µ–ª—è–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã –ø–æ –∑–∞–ø—è—Ç–æ–π –∏ —É–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
    #             args: List[str] = [arg.strip() for arg in args_str.split(',')] if args_str else []
    #
    #             # –í—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏
    #             return method(*args)
    #         else:
    #             # –ï—Å–ª–∏ —Å–∫–æ–±–æ–∫ –Ω–µ—Ç, –ø—Ä–æ—Å—Ç–æ –≤—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ –±–µ–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
    #             return getattr(self, attribute_name, "Not Found keyboard")

    def get_keyboard(self, call: Optional[str] = None) -> Any:
        """
        –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –≤—ã–∑—ã–≤–∞–µ—Ç –º–µ—Ç–æ–¥ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –ø–æ —Å—Ç—Ä–æ–∫–µ –≤–∏–¥–∞
        ``"method_name(1, 'txt', True)"`` –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ ``"property_name"``.

        :param call: –°—Ç—Ä–æ–∫–∞ —Å –≤—ã–∑–æ–≤–æ–º –∏–ª–∏ –∏–º–µ–Ω–µ–º –∞—Ç—Ä–∏–±—É—Ç–∞.
        :raises ValueError: –ï—Å–ª–∏ —Ñ–æ—Ä–º–∞—Ç —Å—Ç—Ä–æ–∫–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω.
        :raises AttributeError: –ï—Å–ª–∏ –º–µ—Ç–æ–¥/–∞—Ç—Ä–∏–±—É—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.
        :raises TypeError: –ï—Å–ª–∏ –ø–æ–ø—ã—Ç–∫–∞ –≤—ã–∑–≤–∞—Ç—å –Ω–µ-callable.
        """
        if call is None:
            raise ValueError("call may not be None")

        # –í—ã–∑–æ–≤ —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏
        if '(' in call and call.rstrip().endswith(')'):
            name, args = self._parse_call(call)
            method = self._get_callable(name)
            return method(*args)

        # –ü—Ä–æ—Å—Ç–æ –∞—Ç—Ä–∏–±—É—Ç/–º–µ—Ç–æ–¥ –±–µ–∑ —Å–∫–æ–±–æ–∫
        attr = getattr(self, call, None)
        if attr is None:
            raise AttributeError(f"{call!r} not found in {self.__class__.__name__}")
        return attr() if callable(attr) else attr

    # ---- –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ private-–º–µ—Ç–æ–¥—ã ----
    _call_re = re.compile(r"\s*(\w+)\s*\((.*)\)\s*")

    def _parse_call(self, text: str) -> tuple[str, List[Any]]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (–∏–º—è, [–∞—Ä–≥—É–º–µ–Ω—Ç—ã])."""
        m = self._call_re.fullmatch(text)
        if not m:
            raise ValueError(f"Invalid call syntax: {text!r}")

        name, arg_str = m.groups()
        if not arg_str.strip():
            return name, []

        lexer = shlex.shlex(arg_str, posix=True)
        lexer.whitespace_split = True
        lexer.whitespace = ','
        args = [ast.literal_eval(tok) for tok in lexer]
        return name, args

    def _get_callable(self, name: str) -> Callable[..., Any]:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –∞—Ç—Ä–∏–±—É—Ç —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ —è–≤–ª—è–µ—Ç—Å—è –≤—ã–∑—ã–≤–∞–µ–º—ã–º."""
        attr = getattr(self, name, None)
        if attr is None:
            raise AttributeError(f"{name!r} not found in {self.__class__.__name__}")
        if not callable(attr):
            raise TypeError(f"{name!r} is not callable")
        return attr
    # ---------------------------

    @staticmethod
    def build_inline_keyboard(
            rows: list[list[dict[str, str | bool | dict | None]]]
    ) -> InlineKeyboardMarkup:
        """
        –ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫, –∫–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞ ‚Äî —Å–ø–∏—Å–æ–∫ –∫–Ω–æ–ø–æ–∫ (—Å–ª–æ–≤–∞—Ä–µ–π —Å –∫–ª—é—á–∞–º–∏ text –∏ callback_data/url/...).
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç InlineKeyboardMarkup —Å –Ω—É–∂–Ω–æ–π —Ä–∞—Å–∫–ª–∞–¥–∫–æ–π.
        """
        inline_keyboard = []

        for row in rows:
            button_row = []

            for btn in row:
                text = btn.get("text")
                if not text:
                    raise ValueError("–ö–∞–∂–¥–∞—è –∫–Ω–æ–ø–∫–∞ –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∫–ª—é—á 'text'.")

                action_keys = (
                    "callback_data",
                    "url",
                    "switch_inline_query",
                    "switch_inline_query_current_chat",
                    "callback_game",
                    "pay",
                )

                button_kwargs = {
                    key: btn[key] for key in action_keys if key in btn and btn[key] is not None
                }

                if not button_kwargs:
                    raise ValueError(f"–ö–Ω–æ–ø–∫–∞ '{text}' –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–µ–π—Å—Ç–≤–∏—è.")

                button = InlineKeyboardButton(text=text, **button_kwargs)
                button_row.append(button)

            inline_keyboard.append(button_row)

        return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)

    # –°–æ–±–∏—Ä–∞–µ—Ç InlineKeyboardMarkup –∏–∑ –ø–∞—Ä (—Ç–µ–∫—Å—Ç, callback) —Å –Ω—É–∂–Ω–æ–π —à–∏—Ä–∏–Ω–æ–π —Å—Ç—Ä–æ–∫–∏.
    @staticmethod
    def build_kb(
            pairs: Iterable[Tuple[str, str]],
            *,
            row_width: int = 2,
            tail_rows: Sequence[Sequence[Tuple[str, str]]] = (),
    ) -> InlineKeyboardMarkup:
        """
        pairs      ‚Äì –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å (text, callback_data)
        row_width  ‚Äì —Å–∫–æ–ª—å–∫–æ –∫–Ω–æ–ø–æ–∫ –≤ —Å—Ç—Ä–æ–∫–µ
        tail_rows  ‚Äì —Å–ø–∏—Å–æ–∫ –≥–æ—Ç–æ–≤—ã—Ö —Å—Ç—Ä–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–¥–æ –ø—Ä–∏-–∫–ª–µ–∏—Ç—å –≤ –∫–æ–Ω–µ—Ü
        """
        kb = InlineKeyboardBuilder()
        for batch in batched(pairs, row_width):
            kb.row(*(InlineKeyboardButton(text=text, callback_data=cb) for text, cb in batch if text))
        for tr in tail_rows:
            kb.row(*(InlineKeyboardButton(text=text, callback_data=cb) for text, cb in tr if text))
        return kb.as_markup()

    # „Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞
    #   ‚ñ∫ –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    # „Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞
    # create_invoice() -> create_billing()
    def create_billing(self, link_pay: str, payment_id: str) -> InlineKeyboardMarkup:
        return self.build_inline_keyboard([
            [{"text": "üí≥ –û–ø–ª–∞—Ç–∏—Ç—å", "url": link_pay}],
            [{"text": "üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–ª–∞—Ç–µ–∂", "callback_data": "check_pay_" + payment_id}],
            [{"text": "üö´ –û—Ç–º–µ–Ω–∏—Ç—å –ø–ª–∞—Ç–µ–∂", "callback_data": "canceled_payment_" + payment_id}],
            [{"text": "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "callback_data": "choose_tariff"}],
        ])

    def cancel_subscription(self, payment_id: str) -> InlineKeyboardMarkup:
        return self.build_inline_keyboard([
            [{"text": "‚õîÔ∏è –û—Ç–º–µ–Ω–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", "callback_data": "cancel_subscription_" + payment_id}],
            [{"text": "–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", "callback_data": "choose_tariff"}],
        ])

    def verify_invoice(self, payment_id: str) -> InlineKeyboardMarkup:
        return self.build_inline_keyboard([
            [{"text": "üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–ª–∞—Ç–µ–∂", "callback_data": "check_pay_" + payment_id}],
            [{"text": "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "callback_data": "choose_tariff"}],
        ])

    def save_params(self) -> InlineKeyboardMarkup:
        return self.build_inline_keyboard([
            [{"text": "üöÄ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ —Ä–∞–±–æ—Ç—É", "callback_data": "task_save"}],
            [{"text": "–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", "callback_data": "coefs_confirm"}],
        ])
    # „Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞
    #   ‚ñ∫ –°–æ–∑–¥–∞–Ω–∏–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∫–ª–∞–≤–∏–∞—Ç—É—Ä —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    # „Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞
    # def box_type(
    #         self,
    #         dictionary: dict[int, ...] | None = None,
    #         back: bool = False,
    #         warehouse_id: int = 0,
    #         page: int = 0,
    #         box_default: list[int] = [],
    #         mode: str = ''
    # ) -> InlineKeyboardMarkup:
    #     checked = {5: 'üü¢ ', 6: 'üü¢ ', 2: 'üü¢ '} if dictionary else {}
    #     confirm = (
    #         [InlineKeyboardButton(text="–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä ‚úÖ", callback_data="confirm_box_type")]
    #         if dictionary and box_default != dictionary else []
    #     )
    #     back_cb: str = (
    #         f"task_update_select_{warehouse_id}_{page}"
    #         if back else f"task_mode_{mode}"
    #     )
    #
    #     return self.build_inline_keyboard([
    #         [{
    #             "text": f"{checked.get(5, '')}–ú–æ–Ω–æ–ø–∞–ª–ª–µ—Ç—ã",
    #             "callback_data": f"box_type_mono_{warehouse_id}_{page}"
    #         }],
    #         [{
    #             "text": f"{checked.get(6, '')}–°—É–ø–µ—Ä—Å–µ–π—Ñ",
    #             "callback_data": f"box_type_safe_{warehouse_id}_{page}"
    #         }],
    #         [{
    #             "text": f"{checked.get(2, '')}–ö–æ—Ä–æ–±–∞",
    #             "callback_data": f"box_type_pan_{warehouse_id}_{page}"
    #         }],
    #         confirm,
    #         [{
    #             "text": "–ù–∞–∑–∞–¥ ‚Ü©Ô∏è",
    #             "callback_data": back_cb
    #         }],
    #     ])

    # @staticmethod
    # def coefs(
    #         self,
    #         coef: dict[int, int] | None = None,
    #         back: bool = False,
    #         warehouse_id: int = 0,
    #         page: int = 0,
    #         coef_default: str = ''
    # ) -> InlineKeyboardMarkup:
    #     coef = coef or {}
    #     coef_map: dict[str, str] = {
    #         f"coefs_{i}": "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ" if i == 0 else f"–ö–æ—ç—Ñ. –¥–æ —Ö{i}" for i in range(21)
    #     }
    #
    #     selected = next((key for key, i in zip(coef_map, range(21)) if i in coef), '')
    #
    #     buttons: list[list[InlineKeyboardButton]] = []
    #     row: list[InlineKeyboardButton] = []
    #
    #     for key, label in coef_map.items():
    #         text = f"{'üü¢ ' if key == selected else ''}{label}"
    #         row.append(InlineKeyboardButton(text=text, callback_data=key))
    #         if len(row) == 3:
    #             buttons.append(row)
    #             row = []
    #
    #     if row:
    #         buttons.append(row)
    #
    #     if coef and (selected or str(next(iter(coef), '')) != coef_default):
    #         buttons.append([InlineKeyboardButton(text="–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä ‚úÖ", callback_data="confirm_coef")])
    #
    #     back_data = f"task_update_select_{warehouse_id}_{page}" if back else "confirm_selection"
    #     buttons.append([InlineKeyboardButton(text="–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", callback_data=back_data)])
    #
    #     return InlineKeyboardMarkup(inline_keyboard=buttons)

    # „Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞
    #   ‚ñ∫ –°–æ–∑–¥–∞–Ω–∏–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∫–ª–∞–≤–∏–∞—Ç—É—Ä —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    # „Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞
    # üöõ ‚ö° üéØ üìç
    # –í—ã–±–æ—Ä —Å–∫–ª–∞–¥–æ–≤
    def create_warehouse_list(
            self,
            page_data: ResponseWarehouses,
            selected_warehouses: list[int],
            selected_list: list[int],
            existing_whs_ids: list[int]
    ) -> InlineKeyboardMarkup:
        # --- –¥–∞–Ω–Ω—ã–µ –∏–∑ –º–æ–¥–µ–ª–∏: –ü–∞—Ä—Å–∏–Ω–≥ Pydantic –º–æ–¥–µ–ª–∏ --------------------------
        warehouses = page_data.warehouses
        page_idx: int = page_data.page_index
        total_pages = page_data.total_pages
        url = f"task_mode_{page_data.mode}"

        # --- –æ—Å–Ω–æ–≤–Ω–∞—è —Å–µ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫ ----------------------------------------------
        pairs: list[tuple[str, str]] = []
        for warehouse in warehouses:
            wid = warehouse["id"]
            name = warehouse["name"]

            if wid in existing_whs_ids:
                label = f"üîî {name}"
                cb_data = f"ignore_wh_{wid}"
            else:
                label = f"üü¢ {name}" if wid in (*selected_warehouses, *selected_list) else name
                cb_data = f"{url}_id{wid}"

            pairs.append((label, cb_data))

        # --- ¬´—Ö–≤–æ—Å—Ç¬ª (–ø–∞–≥–∏–Ω–∞—Ü–∏—è, –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ, –Ω–∞–∑–∞–¥) ---------------------------
        tail_rows: list[list[tuple[str, str]]] = []
        pagination: list[tuple[str, str]] = []

        if page_idx > 0:
            pagination.append(("‚¨ÖÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", f"{url}_{page_idx - 1}"))
        if page_idx < total_pages - 1:
            pagination.append(("–°–ª–µ–¥—É—é—â–∞—è ‚û°Ô∏è", f"{url}_{page_idx + 1}"))
        if pagination:
            tail_rows.append(pagination)

        if selected_warehouses:
            tail_rows.append([("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä ‚úÖ", f"{url}_confirm")])

        tail_rows.append([("–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", "create_task")])

        # --- —Å–±–æ—Ä–∫–∞ --------------------------------------------------------------
        return self.build_kb(pairs, row_width=2, tail_rows=tail_rows)

    # üì¶ ‚úÖ
    # –í—ã–±–æ—Ä —Ç–∏–ø–æ–≤ –∫–æ—Ä–æ–±–æ–∫
    def box_type(
            self,
            data: ResponseBoxTypes,
            box_titles: dict[str, str],
            url: str = 'box_type',
            url_back: Optional[str] = None
    ) -> InlineKeyboardMarkup:
        # --- —à–æ—Ä—Ç–∫–∞—Ç—ã –∏ –º–∞—Ä–∫–µ—Ä—ã ----------------------------------------------------
        selected = set(data.selected) or []  # –æ—Ç–º–µ—á–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã
        checked = {i: "üü¢ " for i in (selected or {})}  # –∑–µ–ª—ë–Ω–∞—è —Ç–æ—á–∫–∞ —É –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö
        if url_back is None:
            url_back = f"task_mode_{data.mode}"  # –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫ –≤—ã–±–æ—Ä—É —Å–∫–ª–∞–¥–æ–≤

        # --- –∫–Ω–æ–ø–∫–∏ —Ç–∏–ø–æ–≤ –∫–æ—Ä–æ–±–æ–∫ --------------------------------------------------
        pairs: list[tuple[str, str]] = []
        for bt in BoxType:  # Enum –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Ñ–∏–∫—Å. –ø–æ—Ä—è–¥–æ–∫
            title = box_titles[bt]  # "–ú–æ–Ω–æ–ø–∞–ª–ª–µ—Ç—ã" / ‚Ä¶
            code = bt.value  # "mono" / "safe" / "pan"
            bullet = "üü¢ " if code in selected else ""  # –∑–µ–ª—ë–Ω–∞—è –º–µ—Ç–∫–∞
            cb_data = f"{url}_{code}_{data.warehouse_id}_{data.page}"

            pairs.append((f"{bullet}{title}", cb_data))

        # --- —Ö–≤–æ—Å—Ç–æ–≤—ã–µ –∫–Ω–æ–ø–∫–∏ (confirm / back / pagination) ------------------------
        tail: list[list[tuple[str, str]]] = []

        # confirm ‚Äì –ø–æ–∫–∞–∑—ã–≤–∞–µ–º, –µ—Å–ª–∏ –≤—ã–±–æ—Ä –µ—Å—Ç—å –∏ –æ–Ω –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –¥–µ—Ñ–æ–ª—Ç–∞
        # print(set(data.box_default), selected)
        if selected and list(set((data.box_default or []))) != list(selected):
            tail.append([("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä ‚úÖ", f"{url}_confirm")])

        # –Ω–∞–∑–∞–¥
        back_cb: str = f"task_update_select_{data.warehouse_id}_{data.page}" if data.back else url_back
        tail.append([("–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", back_cb)])

        # --- —Å–±–æ—Ä–∫–∞ –∏ –≤–æ–∑–≤—Ä–∞—Ç -------------------------------------------------------
        return self.build_kb(pairs, row_width=1, tail_rows=tail)

    # üßÆ üìä
    # –í—ã–±–æ—Ä –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤
    def coefs(
            self,
            data: ResponseCoefs,
            url: str = 'coefs',
            url_back: Optional[str] = None
    ) -> InlineKeyboardMarkup:
        # --- —à–æ—Ä—Ç–∫–∞—Ç—ã –∏ –º–∞—Ä–∫–µ—Ä—ã --------------------------------------------------
        selected = data.selected                    # –æ–¥–∏–Ω-–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π int | None
        if url_back is None:
            url_back = f"task_mode_{data.mode}_confirm" # –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫ –≤—ã–±–æ—Ä—É box-types

        # --- –∫–Ω–æ–ø–∫–∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ (21 —à—Ç., –ø–æ 3 –≤ —Å—Ç—Ä–æ–∫–µ) -----------------------
        pairs: list[tuple[str, str]] = []
        for coef_id, title in COEF_TITLES.items():  # 0 ‚Üí "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ", ‚Ä¶
            bullet = "üü¢ " if coef_id == selected else ""
            cb_data = f"{url}_{coef_id}"
            pairs.append((f"{bullet}{title}", cb_data))

        # --- ¬´—Ö–≤–æ—Å—Ç¬ª (confirm / back) -------------------------------------------
        tail: list[list[tuple[str, str]]] = []

        # confirm ‚Äì –µ—Å–ª–∏ –≤—ã–±–æ—Ä –µ—Å—Ç—å –∏ –æ–Ω –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –¥–µ—Ñ–æ–ª—Ç–∞
        if selected is not None and data.coef_default != selected:
            tail.append([("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä ‚úÖ", f"{url}_confirm")])

        back_cb = (
            f"task_update_select_{data.warehouse_id}_{data.page}"
            if data.back else url_back
        )
        tail.append([("–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", back_cb)])

        # --- —Å–±–æ—Ä–∫–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---------------------------------------------------
        return self.build_kb(pairs, row_width=3, tail_rows=tail)

    # üìÜ üïë
    # –í—ã–±–æ—Ä –¥–∞—Ç—ã –ø–æ—Å—Ç–∞–≤–∫–∏ (–ø–µ—Ä–∏–æ–¥–∞ –≤—Ä–µ–º–µ–Ω–∏)
    def create_select_date(
            self,
            url: str = 'select_date',
            url_back: str = 'box_type_confirm',
            url_calendar: str = 'select_diapason'
    ) -> InlineKeyboardMarkup:
        # --- —à–æ—Ä—Ç–∫–∞—Ç—ã -----------------------------------------------------------
        # f"task_update_select_{warehouse_id}_{page}"

        # --- –æ—Å–Ω–æ–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ ----------------------------------------------------
        pairs: list[tuple[str, str]] = [
            ("–°–µ–≥–æ–¥–Ω—è", f"{url}_today"),
            ("–ó–∞–≤—Ç—Ä–∞", f"{url}_tomorrow"),
            ("–ù–µ–¥–µ–ª—è", f"{url}_week"),
            ("–ú–µ—Å—è—Ü", f"{url}_month"),
            ("–í—ã–±—Ä–∞—Ç—å –Ω–∞ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ", url_calendar),
        ]

        # --- ¬´—Ö–≤–æ—Å—Ç¬ª (—Ç–æ–ª—å–∫–æ –∫–Ω–æ–ø–∫–∞ ¬´–ù–∞–∑–∞–¥¬ª) ------------------------------------
        tail = [[("–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", url_back)]]

        # --- —Å–±–æ—Ä–∫–∞ –∏ –≤–æ–∑–≤—Ä–∞—Ç ----------------------------------------------------
        # row_width=2 ‚Üí ¬´–°–µ–≥–æ–¥–Ω—è|–ó–∞–≤—Ç—Ä–∞¬ª, ¬´–ù–µ–¥–µ–ª—è|–ú–µ—Å—è—Ü¬ª, ¬´–ö–∞–ª–µ–Ω–¥–∞—Ä—å¬ª, ¬´–ù–∞–∑–∞–¥¬ª
        return self.build_kb(pairs, row_width=2, tail_rows=tail)

    def create_alarm_list(
            self,
            page_data: ResponseTasks,
            url: str = 'toggle_alarm',
            prefix_icon: tuple[str, str] = ("üîî", "üîï"),
            alarm_helper_btn: bool = True,
            back: str = 'alarm_setting'
    ) -> InlineKeyboardMarkup:
        # --- –¥–∞–Ω–Ω—ã–µ –∏–∑ –º–æ–¥–µ–ª–∏: –ü–∞—Ä—Å–∏–Ω–≥ Pydantic –º–æ–¥–µ–ª–∏ --------------------------
        warehouses = page_data.warehouses_names_list
        page: int = page_data.page_index
        total_pages = page_data.total_pages
        alarm_status: dict[int, int] = {item.warehouse_id: item.alarm for item in page_data.tasks}

        # --- –æ—Å–Ω–æ–≤–Ω–∞—è —Å–µ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫ (–ø–æ 2 –≤ —Ä—è–¥) -------------------------------------
        pairs: list[tuple[str, str]] = []
        for warehouse in warehouses:
            wid = warehouse["id"]
            name = warehouse["name"]
            icon = prefix_icon[0] if alarm_status.get(wid) else prefix_icon[1]
            label = f"{icon} {name}"
            pairs.append((label, f"{url}_{wid}_{page}"))

        # --- ¬´—Ö–≤–æ—Å—Ç¬ª (–ø–∞–≥–∏–Ω–∞—Ü–∏—è + –¥–µ–π—Å—Ç–≤–∏—è + –Ω–∞–∑–∞–¥) ---------------------------------
        tail_rows: list[list[tuple[str, str]]] = []
        pagination: list[tuple[str, str]] = []

        # –º—ã –ø—Ä–µ–¥—É—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º, —á—Ç–æ —Å—Ç–æ–∏—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤ 30 —Å–∫–ª–∞–¥–æ–≤, –ø–æ—ç—Ç–æ–º—É –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è:

        # if page > 0:
        #     pagination.append(("‚¨ÖÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", f"alarm_edit_{page - 1}"))
        # if page < total_pages - 1:
        #     pagination.append(("–°–ª–µ–¥—É—é—â–∞—è ‚û°Ô∏è", f"alarm_edit_{page + 1}"))
        # if pagination:
        #     tail_rows.append(pagination)

        if warehouses and alarm_helper_btn:
            tail_rows.append([("–í–∫–ª—é—á–∏—Ç—å –¥–ª—è –≤—Å–µ—Ö", "alarm_all_on")])
            tail_rows.append([("–û—Ç–∫–ª—é—á–∏—Ç—å –¥–ª—è –≤—Å–µ—Ö", "alarm_all_off")])

        tail_rows.append([("–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", back)])

        # --- —Å–±–æ—Ä–∫–∞ -----------------------------------------------------------------
        return self.build_kb(pairs, row_width=2, tail_rows=tail_rows)

    # @staticmethod
    # def create_alarm_list(
    #         self,
    #         warehouses: list[dict[str, int | str]],
    #         alarm_status: dict[int, bool],
    #         page: int,
    #         total_pages: int
    # ) -> InlineKeyboardMarkup:
    #     buttons: list[list[InlineKeyboardButton]] = []
    #     row: list[InlineKeyboardButton] = []
    #
    #     for warehouse in warehouses:
    #         wid = warehouse["id"]
    #         name = f"{'üîî' if alarm_status.get(wid) else 'üîï'} {warehouse['name']}"
    #         row.append(InlineKeyboardButton(text=name, callback_data=f"toggle_alarm_{wid}_{page}"))
    #
    #         if len(row) == 2:
    #             buttons.append(row)
    #             row = []
    #
    #     if row:
    #         buttons.append(row)
    #
    #     pagination: list[InlineKeyboardButton] = []
    #     if page > 0:
    #         pagination.append(InlineKeyboardButton(text="‚¨ÖÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f"alarm_page_{page - 1}"))
    #     if page < total_pages - 1:
    #         pagination.append(InlineKeyboardButton(text="–°–ª–µ–¥—É—é—â–∞—è ‚û°Ô∏è", callback_data=f"alarm_page_{page + 1}"))
    #     if pagination:
    #         buttons.append(pagination)
    #
    #     if warehouses:
    #         buttons.append([
    #             InlineKeyboardButton(text="–í–∫–ª—é—á–∏—Ç—å –¥–ª—è –≤—Å–µ—Ö", callback_data="alarm_all_on")
    #         ])
    #         buttons.append([
    #             InlineKeyboardButton(text="–û—Ç–∫–ª—é—á–∏—Ç—å –¥–ª—è –≤—Å–µ—Ö", callback_data="alarm_all_off")
    #         ])
    #
    #     buttons.append([InlineKeyboardButton(text="–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", callback_data="alarm_setting")])
    #     return InlineKeyboardMarkup(inline_keyboard=buttons)

    @staticmethod
    def create_task_list(
            self,
            warehouses: list[dict[str, int | str]],
            alarm_status: dict[int, bool],
            page: int,
            total_pages: int
    ) -> InlineKeyboardMarkup:
        buttons: list[list[InlineKeyboardButton]] = []
        row: list[InlineKeyboardButton] = []

        for warehouse in warehouses:
            wid = warehouse["id"]
            name = str(warehouse["name"])  # –ó–Ω–∞—á–µ–Ω–∏–µ alarm –Ω–∏–∫–∞–∫ –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ –∏–º—è
            row.append(InlineKeyboardButton(text=name, callback_data=f"task_update_select_{wid}_{page}"))

            if len(row) == 2:
                buttons.append(row)
                row = []

        if row:
            buttons.append(row)

        pagination: list[InlineKeyboardButton] = []
        if page > 0:
            pagination.append(InlineKeyboardButton(text="‚¨ÖÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f"task_update_page_{page - 1}"))
        if page < total_pages - 1:
            pagination.append(InlineKeyboardButton(text="–°–ª–µ–¥—É—é—â–∞—è ‚û°Ô∏è", callback_data=f"task_update_page_{page + 1}"))
        if pagination:
            buttons.append(pagination)

        buttons.append([InlineKeyboardButton(text="–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", callback_data="my_tasks")])
        return InlineKeyboardMarkup(inline_keyboard=buttons)


    def edit_task_warehouse(
            self,
            warehouse_id: int,
            page: int
    ) -> InlineKeyboardMarkup:
         return self.build_inline_keyboard([
            [{
                "text": "üì¶ –ò–∑–º–µ–Ω–∏—Ç—å —Ç–∏–ø —É–ø–∞–∫–æ–≤–∫–∏",
                "callback_data": f"task_update_box_{warehouse_id}_{page}"
            }],
            [{
                "text": "üßÆ –ò–∑–º–µ–Ω–∏—Ç—å –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç",
                "callback_data": f"task_update_coef_{warehouse_id}_{page}"
            }],
            [{
                "text": "üìÖ –ò–∑–º–µ–Ω–∏—Ç—å –ø–µ—Ä–∏–æ–¥",
                "callback_data": f"task_update_date_{warehouse_id}_{page}"
            }],
            [{
                "text": "üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É",
                "callback_data": f"task_delete_id{warehouse_id}_{page}"
            }],
            [{
                "text": "–ù–∞–∑–∞–¥ ‚Ü©Ô∏è",
                "callback_data": f"task_update_page_{page}"
            }],
        ])

    @staticmethod
    def generate_calendar(
        *,
        year: int | None = None,  # –≤—ã–±—Ä–∞–Ω–Ω—ã–π –≥–æ–¥   (None ‚Üí —Ç–µ–∫—É—â–∏–π)
        month: int | None = None,  # –≤—ã–±—Ä–∞–Ω–Ω—ã–π –º–µ—Å—è—Ü (None ‚Üí —Ç–µ–∫—É—â–∏–π)
        highlight_day: int | None = None,  # ¬´–≤—ã–±—Ä–∞–Ω–Ω—ã–π¬ª –¥–µ–Ω—å (None ‚Üí –Ω–µ—Ç)
        confirm: bool = False,  # –ø–æ–∫–∞–∑–∞—Ç—å –∫–Ω–æ–ø–∫—É ¬´–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä¬ª
        url: str = 'select_day',
        url_confirm: str = 'date_confirm',
        url_back: str = 'coefs_confirm',
        url_change: str = 'change_month'
    ) -> InlineKeyboardMarkup:
        """
        –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∏–Ω–ª–∞–π–Ω-–∫–∞–ª–µ–Ω–¥–∞—Ä—å –æ–¥–Ω–æ–≥–æ –º–µ—Å—è—Ü–∞.

        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ  [–ú–∞–π 2025]   ‚îÇ
        ‚îÇ –ü–Ω –í—Ç –°—Ä –ß—Ç ‚Ä¶ ‚îÇ
        ‚îÇ  1  2  3 ...  ‚îÇ
        ‚îÇ               ‚îÇ
        ‚îÇ ‚óÄÔ∏è –°–µ–≥–æ–¥–Ω—è ‚ñ∂Ô∏è ‚îÇ
        ‚îÇ   –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å ‚îÇ  (–µ—Å–ª–∏ confirm=True)
        ‚îÇ      –ù–∞–∑–∞–¥    ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        """
        # ‚îÄ‚îÄ 0. –¥–∞—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ------------------------------------------
        today = datetime.now()
        year = year or today.year
        month = month or today.month
        highlight_day = highlight_day or today.day

        # ‚îÄ‚îÄ 1. –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∏ –¥–Ω–∏ –Ω–µ–¥–µ–ª–∏ -------------------------------------
        # –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –º–µ—Å—è—Ü–µ–≤:
        MONTHS: list[str] = [
            "–Ø–Ω–≤", "–§–µ–≤", "–ú–∞—Ä", "–ê–ø—Ä", "–ú–∞–π", "–ò—é–Ω",
            "–ò—é–ª", "–ê–≤–≥", "–°–µ–Ω", "–û–∫—Ç", "–ù–æ—è", "–î–µ–∫"
        ]
        WEEKDAYS: list[str] = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
        kb: list[list[InlineKeyboardButton]] = [
            # –º–µ—Å—è—Ü + –≥–æ–¥
            [InlineKeyboardButton(text=f"[{MONTHS[month - 1]} {year}]", callback_data="ignore")],
            # —à–∞–ø–∫–∞ –¥–Ω–µ–π –Ω–µ–¥–µ–ª–∏
            [InlineKeyboardButton(text=day, callback_data="ignore") for day in WEEKDAYS],
        ]

        # ‚îÄ‚îÄ 2. —Å–µ—Ç–∫–∞ –¥–Ω–µ–π ---------------------------------------------------
        for week in calendar.monthcalendar(year, month):
            row: list[InlineKeyboardButton] = []
            for day in week:
                if day == 0:  # –ø—É—Å—Ç–∞—è —è—á–µ–π–∫–∞
                    row.append(InlineKeyboardButton(text=" ", callback_data="ignore"))
                    continue

                # –ø–æ–¥—Å–≤–µ—Ç–∫–∞ ¬´—Å–µ–≥–æ–¥–Ω—è¬ª –∏–ª–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –¥–Ω—è
                mark = "‚ùó" if (
                        day == highlight_day and
                        month == today.month and
                        year == today.year
                ) else ""

                row.append(
                    InlineKeyboardButton(
                        text=f"{mark}{day}{mark}",
                        callback_data=f"{url}_{year}_{month}_{day}"
                    )
                )
            kb.append(row)

        # ‚îÄ‚îÄ 3. –Ω–∞–≤–∏–≥–∞—Ü–∏—è –º–µ—Å—è—Ü –Ω–∞–∑–∞–¥ / —Å–µ–≥–æ–¥–Ω—è / –º–µ—Å—è—Ü –≤–ø–µ—Ä—ë–¥ --------------
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –∏ —Å–ª–µ–¥—É—é—â–µ–≥–æ –º–µ—Å—è—Ü–∞
        prev_m = month - 1 or 12
        next_m = month + 1 if month < 12 else 1
        prev_y = year - 1 if month == 1 else year
        next_y = year + 1 if month == 12 else year

        # –ù–∏–∂–Ω–∏–π —Ä—è–¥ –∫–Ω–æ–ø–æ–∫: –Ω–∞–∑–∞–¥ –ø–æ –º–µ—Å—è—Ü—É, —Å–µ–≥–æ–¥–Ω—è, –≤–ø–µ—Ä—ë–¥ –ø–æ –º–µ—Å—è—Ü—É
        kb.append([
            InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data=f"{url_change}_{prev_y}_{prev_m}"),
            InlineKeyboardButton(
                text="–°–µ–≥–æ–¥–Ω—è",
                callback_data=f"{url}_{today.year}_{today.month}_{today.day}"
            ),
            InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"{url_change}_{next_y}_{next_m}"),
        ])

        # ‚îÄ‚îÄ 4. confirm / back ----------------------------------------------
        if confirm:
            kb.append([InlineKeyboardButton(text="–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä ‚úÖ", callback_data=url_confirm)])

        # –ö–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥"
        kb.append([InlineKeyboardButton(text="–ù–∞–∑–∞–¥ ‚Ü©Ô∏è", callback_data=url_back)])

        # ‚îÄ‚îÄ 5. –≤–æ–∑–≤—Ä–∞—Ç -------------------------------------------------------
        return InlineKeyboardMarkup(inline_keyboard=kb)

    @staticmethod
    def generate_pagination_keyboard(
            current_page: int,
            total_tasks: int,
            page_size: int = 5,
            callback_data: str = "paginate_",
            base_keyboard: InlineKeyboardMarkup | None = None
    ) -> InlineKeyboardMarkup:
        """
        –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –∏—Ö –∫ –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–π –±–∞–∑–æ–≤–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ.

        :param self:
        :param current_page: –¢–µ–∫—É—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞.
        :param total_tasks: –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–¥–∞—á.
        :param page_size: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–¥–∞—á –Ω–∞ –æ–¥–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ.
        :param callback_data: –ü—Ä–µ—Ñ–∏–∫—Å callback_data –¥–ª—è –∫–Ω–æ–ø–æ–∫.
        :param base_keyboard: –°—É—â–µ—Å—Ç–≤—É—é—â–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ (InlineKeyboardMarkup) –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ).
        :return: InlineKeyboardMarkup —Å –∫–Ω–æ–ø–∫–∞–º–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏.
        """
        # total_pages = ((total_tasks - 1) // page_size + 1) - 1
        total_pages: int = (total_tasks - 1) // page_size

        buttons: list[InlineKeyboardButton] = [
            InlineKeyboardButton(text="‚¨ÖÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f"{callback_data}{current_page - 1}")
            if current_page > 0 else None,
            InlineKeyboardButton(text="–°–ª–µ–¥—É—é—â–∞—è ‚û°Ô∏è", callback_data=f"{callback_data}{current_page + 1}")
            if current_page < total_pages else None
        ]
        buttons = [btn for btn in buttons if btn]

        if not base_keyboard:
            base_keyboard = InlineKeyboardMarkup(inline_keyboard=[])
        else:
            base_keyboard.inline_keyboard = [
                row for row in base_keyboard.inline_keyboard
                if all(btn.text not in {"‚¨ÖÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", "–°–ª–µ–¥—É—é—â–∞—è ‚û°Ô∏è"} for btn in row)
            ]

        if buttons:
            base_keyboard.inline_keyboard.insert(0, buttons)

        return base_keyboard