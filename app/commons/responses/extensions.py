import json
import random
import string
import logging
from collections import defaultdict
from datetime import date, datetime

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ç–∏–ø–∏–∑–∞—Ü–∏—é
from typing import TypeVar, Hashable, Sequence, Iterable, Union, Any, Optional, Tuple, get_args

from ..services.task import TaskService
# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∫–ª–∞—Å—Å –¥–ª—è –≤—ã–≤–æ–¥–∞ —Å–∏—Å—Ç–µ–º–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏ –¥–∞–º–ø–∞ –¥–∞–Ω–Ω—ã—Ö
from ..utils.dump import DebugTools

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º enums –º–æ–¥–µ–ª–∏ –∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
from ...enums.constants import BOX_TITLES_RU, BOX_TITLES
from app.enums.general import TaskMode

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º pydantic –º–æ–¥–µ–ª–∏
from ...schemas.task import TaskRead
from app.schemas.general import ResponseModel
from ...schemas.typed_dict import LangType

# T = TypeVar("T", bound=Hashable) - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –≤ –∫–ª—é—á–∞—Ö —Å–ª–æ–≤–∞—Ä–µ–π (dict), —Å–∫–ª–∞–¥—ã–≤–∞—Ç—å –≤ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ (set)
T = TypeVar("T")

# —Ç–æ, —á—Ç–æ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–º–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏: –ª–∏–±–æ –≥–æ—Ç–æ–≤–∞—è –º–æ–¥–µ–ª—å, –ª–∏–±–æ ¬´–Ω–µ—á—Ç–æ¬ª,
# –∏–∑ —á–µ–≥–æ `format_response()` —Å–¥–µ–ª–∞–µ—Ç –º–æ–¥–µ–ª—å (str / dict / kwargs ...)
ResponseInput = Union[ResponseModel, str, dict[str, Any]]

class BaseHandlerExtensions:
    def __init__(self):
        self.lang: LangType = {}
        self.debug = DebugTools
        self.limit_whs_per_page: int = 30
        self.limit_whs_for_view: int = 10

        self.task_state_template: dict[str, Any] = {
            'current_page': 0,
            'list': [],
            'selected_list': [],
            'box_type': [],
            'coefs': None,
            'period_start': None,
            'period_end': None,
            'mode': '',
            'existing_tasks_ids': [],
            'default': []
        }

        self.BULLET_HUBS = "\n\t üìç"  # –µ–¥–∏–Ω—ã–π —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –¥–ª—è —Å–∫–ª–∞–¥–æ–≤
        self.BULLET_BOXES = "\n\t ‚ñ´Ô∏è"  # –µ–¥–∏–Ω—ã–π —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –¥–ª—è —Ç–∏–ø–æ–≤ —É–ø–∞–∫–æ–≤–æ–∫
        # text = self.lang.get("create_task_list", {}).get("space", "üîí no text")


    @staticmethod
    def format_response(
        text: str | dict[str, object],
        keyboard: Optional[object] = None,
        array_activity: bool = False,
        status: bool = True,
        popup_text: Optional[str] = None,
        popup_alert: Optional[bool] = None,
        type_edit: Optional[str] = 'message'
    ) -> ResponseModel:
        """
        –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç —Å —Ç–µ–∫—Å—Ç–æ–º –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π –≤ –≤–∏–¥–µ —Å–ª–æ–≤–∞—Ä—è.

        :param text: –¢–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞
        :param keyboard: –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –æ—Ç–≤–µ—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        :param array_activity: –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è —Å–ª–æ–≤–∞—Ä—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π
        :param status: –î–ª—è —É–∫–∞–∑–∞–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
        :param popup_text: –¢–µ–∫—Å—Ç –¥–ª—è –≤—Å–ø–ª—ã–≤–∞—é—â–µ–≥–æ –æ–∫–Ω–∞
        :param popup_alert: –°—Ç–∞—Ç—É—Å –≤—Å–ø–ª—ã–≤–∞—é—â–µ–≥–æ –æ–∫–Ω–∞, True - —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º
        :param type_edit: –¢–∏–ø —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (message –∏–ª–∏ keyboard)
        :return: –°–ª–æ–≤–∞—Ä—å —Å –∫–ª—é—á–∞–º–∏ 'status', 'text' –∏ 'kb'
        """
        return ResponseModel(
            status=status,
            text=text['response'] if array_activity else text,
            kb=text['keyboard'] if array_activity else (keyboard or None),
            popup_text=popup_text,
            popup_alert=popup_alert,
            type_edit=type_edit
        )

    @staticmethod
    def format_alert(
            status: bool = True,
            popup_text: Optional[str] = None,
            popup_alert: Optional[bool] = None,
    ) -> ResponseModel:
        """
        –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç —Å —Ç–µ–∫—Å—Ç–æ–º –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π –≤ –≤–∏–¥–µ —Å–ª–æ–≤–∞—Ä—è.

        :param text: –¢–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞
        :param keyboard: –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –æ—Ç–≤–µ—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        :param array_activity: –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è —Å–ª–æ–≤–∞—Ä—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π
        :param status: –î–ª—è —É–∫–∞–∑–∞–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
        :param popup_text: –¢–µ–∫—Å—Ç –¥–ª—è –≤—Å–ø–ª—ã–≤–∞—é—â–µ–≥–æ –æ–∫–Ω–∞
        :param popup_alert: –°—Ç–∞—Ç—É—Å –≤—Å–ø–ª—ã–≤–∞—é—â–µ–≥–æ –æ–∫–Ω–∞, True - —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º
        :param type_edit: –¢–∏–ø —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (message –∏–ª–∏ keyboard)
        :return: –°–ª–æ–≤–∞—Ä—å —Å –∫–ª—é—á–∞–º–∏ 'status', 'text' –∏ 'kb'
        """
        return ResponseModel(
            status=status,
            text='',
            kb=None,
            popup_text=popup_text,
            popup_alert=popup_alert,
        )

    def format_responses(
        self,
        *items: ResponseInput | Iterable[ResponseInput]
    ) -> list[ResponseModel]:
        """
        ¬´–ü–∞–∫–µ—Ç–Ω—ã–π¬ª —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä.

        ‚Ä¢ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –ª—é–±–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤:
          - –≥–æ—Ç–æ–≤—ã–µ `ResponseModel`;
          - str / dict (–ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –¥–∞–ª—å—à–µ –≤ `format_response`);
          - –∏—Ç–µ—Ä–∏—Ä—É–µ–º—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –≤—ã—à–µ–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ;
        ‚Ä¢ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `list[ResponseModel]`, —Ñ–∏–ª—å—Ç—Ä—É—è `None`.
        """
        out: list[ResponseModel] = []

        for item in items:
            # --- –∫–æ–ª–ª–µ–∫—Ü–∏—è (list / tuple / set ‚Ä¶) --------------------------
            if isinstance(item, Iterable) and not isinstance(item, (str, bytes, ResponseModel)):
                out.extend(self.format_responses(*item))          # —Ä–µ–∫—É—Ä—Å–∏—è
                continue

            # --- —É–∂–µ –≥–æ—Ç–æ–≤–∞—è –º–æ–¥–µ–ª—å ---------------------------------------
            if isinstance(item, ResponseModel):
                out.append(item)
                continue

            # --- ¬´—Å—ã—Ä—ã–µ¬ª –¥–∞–Ω–Ω—ã–µ ‚Üí —Å–æ–∑–¥–∞—ë–º –º–æ–¥–µ–ª—å —á–µ—Ä–µ–∑ format_response ----
            try:
                model = format_response(text=item)           # type: ignore[arg-type]
            except Exception as e:
                raise TypeError(f"–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø –¥–ª—è format_responses: {type(item)!r}") from e

            out.append(model)

        # —É–¥–∞–ª—è–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ None (–µ—Å–ª–∏ format_response –≤–µ—Ä–Ω—ë—Ç None)
        return [m for m in out if m is not None]

    @staticmethod
    def safe_get(
            seq: Sequence[T],
            index: int,
            default: T | None = None,
    ) -> T | None:
        """
        –ë–µ–∑–æ–ø–∞—Å–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç `seq[index]`, –Ω–µ –ø–æ–¥–Ω–∏–º–∞—è `IndexError`.

        data = ["zero", "one", "two"]
        element = safe_get(data, 1)                 # ‚Üí "one"
        element = safe_get(data, 10)                # ‚Üí None
        element = safe_get(data, 10, default="-")   # ‚Üí "-"
        element = safe_get(data, -1)                # ‚Üí "two"

        letters = ("a", "b", "c")
        element = safe_get(letters, 0)              # ‚Üí "a"

        ‚Ä¢ seq     ‚Äì –ª—é–±–æ–π –∏–Ω–¥–µ–∫—Å–∏—Ä—É–µ–º—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä (`list`, `tuple`, `str`, ‚Ä¶)
        ‚Ä¢ index   ‚Äì —Ü–µ–ª–µ–≤–æ–π –∏–Ω–¥–µ–∫—Å (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è –∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ)
        ‚Ä¢ default ‚Äì –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –∏–Ω–¥–µ–∫—Å –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
        """
        return seq[index] if -len(seq) <= index < len(seq) else default

    @staticmethod
    def validate_ymd(year: int, month: int, day: int) -> date:
        """
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ `year-month-day` –æ–±—Ä–∞–∑—É—é—Ç —Ä–µ–∞–ª—å–Ω—É—é –∫–∞–ª–µ–Ω–¥–∞—Ä–Ω—É—é –¥–∞—Ç—É.

        ‚Ä¢ –ø—Ä–∏ —É—Å–ø–µ—Ö–µ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `datetime.date`;
        ‚Ä¢ –ø—Ä–∏ –æ—à–∏–±–∫–µ ‚Äî –±—Ä–æ—Å–∞–µ—Ç `ValueError`, –≥–¥–µ —É–∂–µ –±—É–¥–µ—Ç —É–∫–∞–∑–∞–Ω–∞ –ø—Ä–∏—á–∏–Ω–∞
          (–Ω–∞–ø—Ä–∏–º–µ—Ä, ¬´day is out of range for month¬ª).
        """
        try:
            return date(year, month, day)
        except ValueError as exc:  # 31 —Ñ–µ–≤, 30 —Ñ–µ–≤ ‚Ä¶ ‚Üê —Å—é–¥–∞
            raise ValueError(
                f"–ù–µ–≤–µ—Ä–Ω–∞—è –¥–∞—Ç–∞: {year:04d}-{month:02d}-{day:02d}"
            ) from exc


    @staticmethod
    def get_or_default(value: Any, expected_type: Union[type, Tuple[type, ...]], default: T) -> T:
        """
        –ü—ã—Ç–∞–µ—Ç—Å—è –ø—Ä–∏–≤–µ—Å—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –∫ –æ–¥–Ω–æ–º—É –∏–∑ –æ–∂–∏–¥–∞–µ–º—ã—Ö —Ç–∏–ø–æ–≤.
        –ï—Å–ª–∏ —É–¥–∞—ë—Ç—Å—è ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –∏–Ω–∞—á–µ ‚Äî default.

        :param value: –ó–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è.
        :param expected_type: –¢–∏–ø –∏–ª–∏ –∫–æ—Ä—Ç–µ–∂ —Ç–∏–ø–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, int, (int, float)).
        :param default: –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å.
        :return: –ü—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–ª–∏ default.
        """
        # –Ø–≤–Ω—ã–µ "–ø—É—Å—Ç—ã–µ" –∑–Ω–∞—á–µ–Ω–∏—è
        if value in (None, "None", "null", ""):
            return default

        if not isinstance(expected_type, tuple):
            expected_type = (expected_type,)

        for typ in expected_type:
            try:
                casted = typ(value)
                if isinstance(casted, typ):
                    return casted
            except (ValueError, TypeError):
                continue

        return default

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    @staticmethod
    def _parse_raw(raw: str | int) -> tuple[int, Optional[int], bool, bool]:
        """raw ‚Üí (page, warehouse_id | None, is_id, is_confirm)"""
        if isinstance(raw, str):
            if raw.startswith("id"):
                return 0, int(raw[2:]), True, False
            if raw.startswith("confirm"):
                return 0, None, False, True
            return int(raw), None, False, False
        return int(raw), None, False, False

    @staticmethod
    def _merge_setup_task(old: dict, **patch) -> dict:
        """–ò–º–º—É—Ç–∞–±–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ setup_task"""
        return {**old, **patch}

    @staticmethod
    def toggle_selection(
            container: Union[list[T], dict[T, Any]],
            key: T | None,
            *,
            single: bool = False,  # single=True ‚Üí —Ä–µ–∂–∏–º ¬´–æ–¥–∏–Ω –≤—ã–±—Ä–∞–Ω–Ω—ã–π¬ª (FLEX)
            value: Any = None,  # payload –¥–ª—è —Å–ª–æ–≤–∞—Ä—è –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏
    ) -> Union[list[T], dict[T, Any]]:
        """
        –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π ¬´–ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å¬ª –≤—ã–±–æ—Ä–∞.

        ‚Ä¢ container ‚Äì –ª–∏–±–æ —Å–ø–∏—Å–æ–∫ ID / Enum-–æ–≤      (list[T])
                      –ª–∏–±–æ —Å–ª–æ–≤–∞—Ä—å {ID|Enum: any}   (dict[T, Any])
        ‚Ä¢ key       ‚Äì —ç–ª–µ–º–µ–Ω—Ç, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –∫–ª–∏–∫–Ω—É–ª–∏ (int, Enum ‚Ä¶)
                      None ‚Üí –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –æ—Å—Ç–∞—ë—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
        ‚Ä¢ single    ‚Äì True  ‚Üí –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –æ—Å—Ç–∞—ë—Ç—Å—è —Ç–æ–ª—å–∫–æ key
                      False ‚Üí –º—É–ª—å—Ç–∏–≤—ã–±–æ—Ä
        ‚Ä¢ value     ‚Äì —á–µ–º –∑–∞–ø–æ–ª–Ω—è—Ç—å dict –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é None)

        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –ù–û–í–´–ô –æ–±—ä–µ–∫—Ç (–∏—Å—Ö–æ–¥–Ω—ã–π –Ω–µ –º—É—Ç–∏—Ä—É–µ—Ç—Å—è).
        """

        if key is None:  # –∫–ª–∏–∫ –±—ã–ª ¬´–º–∏–º–æ¬ª ‚Äì –Ω–∏—á–µ–≥–æ –Ω–µ –º–µ–Ω—è–µ–º
            return container.copy() if isinstance(container, list) else container.copy()

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ —Ä–∞–±–æ—Ç–∞ —Å–æ –°–ü–ò–°–ö–û–ú ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if isinstance(container, list):
            if key in container:  # —Å–Ω—è—Ç—å –≤—ã–±–æ—Ä
                return [x for x in container if x != key]

            # –¥–æ–±–∞–≤–∏—Ç—å
            return [key] if single else container + [key]

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ —Ä–∞–±–æ—Ç–∞ —Å–æ –°–õ–û–í–ê–†–Å–ú ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        new_dict: dict[T, Any] = container.copy()

        if key in new_dict:  # —Å–Ω—è—Ç—å –≤—ã–±–æ—Ä
            new_dict.pop(key)
        else:  # –¥–æ–±–∞–≤–∏—Ç—å
            if single:
                new_dict = {key: value}  # –æ—Å—Ç–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ key
            else:
                new_dict[key] = value

        return new_dict

    @staticmethod
    async def format_tasks_list(
            tasks: list[TaskRead],
            box_titles: BOX_TITLES_RU,
            task_service: TaskService,
    ) -> dict[str, object]:
        """
        –§–æ—Ä–º–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á –ø–æ —Å–∫–ª–∞–¥–∞–º —Å –∞–≥—Ä–µ–≥–∞—Ü–∏–µ–π –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:
        –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ —Å–∫–ª–∞–¥—É, –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—É, –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ç–∏–ø–æ–≤ –∫–æ—Ä–æ–±–æ–∫ –∏ –ø–µ—Ä–∏–æ–¥–∞ –¥–∞—Ç.

        :param tasks: –°–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á –º–æ–¥–µ–ª–∏ TaskRead
        :param box_titles: –°–ª–æ–≤–∞—Ä—å —Å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º ID —Ç–∏–ø–∞ —É–ø–∞–∫–æ–≤–∫–∏ –≤ –µ–≥–æ –Ω–∞–∑–≤–∞–Ω–∏–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä: {5: "–ú–æ–Ω–æ–ø–∞–ª–ª–µ—Ç—ã"}).
        :param task_service: –°–µ—Ä–≤–∏—Å–Ω—ã–π —Å–ª–æ–π, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é—â–∏–π –º–µ—Ç–æ–¥—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∑–∞–¥–∞—á–∞–º–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–∫–ª–∞–¥–æ–≤ –ø–æ ID).
        :return: –°–ª–æ–≤–∞—Ä—å —Å —Ç–µ–∫—Å—Ç–æ–º –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–∫–ª–∞–¥–æ–≤
        """
        split_line = "----------------------"
        today = datetime.now().date()
        result: list[str] = []

        # ‚îÄ‚îÄ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∑–∞–¥–∞—á ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        grouped = defaultdict(lambda: defaultdict(set))
        for task in tasks:
            grouped[task.warehouse_id][task.coefficient].add((task.box_type_id, task.date))

        wh_ids = list(grouped.keys())
        whs_by_ids = await task_service.get_whs_by_ids(wh_ids)
        wh_names = {wh.warehouse_id: wh.warehouse_name for wh in whs_by_ids.warehouses}

        for wh_id, coef_groups in grouped.items():
            name = wh_names.get(wh_id, f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–∫–ª–∞–¥ (ID: {wh_id})")

            for coefficient, box_and_dates in coef_groups.items():
                box_types = sorted({box_titles.get(box, "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø") for box, _ in box_and_dates})
                dates = sorted({date for _, date in box_and_dates})

                if not dates:
                    continue

                date_from = dates[0].date() if isinstance(dates[0], datetime) else dates[0]
                date_to = dates[-1].date() if isinstance(dates[-1], datetime) else dates[-1]
                is_active = "üü¢ –ê–ö–¢–ò–í–ù–û" if date_from <= today <= date_to else "üî¥ –ù–ï–ê–ö–¢–ò–í–ù–û"

                result.append(
                    f"üöõ –°–ö–õ–ê–î: {name}\n"
                    f"üõ† –°–¢–ê–¢–£–°: {is_active}\n"
                    f"üì¶ –£–ü–ê–ö–û–í–ö–ê: {', '.join(box_types)}\n"
                    f"‚öñÔ∏è –ö–û–≠–§–§–ò–¶–ò–ï–ù–¢: –¥–æ —Ö{coefficient}\n"
                    f"üìÖ –ü–ï–†–ò–û–î –ü–û–ò–°–ö–ê –°–õ–û–¢–û–í: —Å <u>{date_from}</u> –ø–æ <u>{date_to}</u>"
                )

        return {
            "text": f"\n{split_line}\n".join(result),
            "total": len(wh_ids)
        }

    def toggle_id(self, items: list[int], wid: Optional[int], mode: TaskMode) -> list[int]:
        """
        ¬´–ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç¬ª —Å–∫–ª–∞–¥ *wid* –≤ —Å–ø–∏—Å–∫–µ *items*, –∏—Å–ø–æ–ª—å–∑—É—è –æ–±—â–∏–π toggle_selection.

        ‚Ä¢ wid is None       ‚Üí —Å–ø–∏—Å–æ–∫ –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è
        ‚Ä¢ wid —É–∂–µ –≤ items   ‚Üí —É–¥–∞–ª—è–µ–º –µ–≥–æ
        ‚Ä¢ wid –Ω–µ—Ç –≤ items   ‚Üí –¥–æ–±–∞–≤–ª—è–µ–º
        ‚Ä¢ mode == FLEX      ‚Üí –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –æ—Å—Ç–∞—ë—Ç—Å—è —Ç–æ–ª—å–∫–æ wid (–æ–¥–∏–Ω–æ—á–Ω—ã–π –≤—ã–±–æ—Ä)

        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è **–Ω–æ–≤—ã–π** —Å–ø–∏—Å–æ–∫ id.
        """
        # if wid is None:  # –∫–ª–∏–∫ –Ω–µ –ø–æ —Å–∫–ª–∞–¥—É
        #     return items.copy()
        #
        # return self.toggle_selection(
        #     container=items,
        #     key=wid,
        #     single=(mode is TaskMode.FLEX),
        # )
        single = mode is TaskMode.FLEX
        return self.toggle_selection(items, wid, single=single)

    def build_selection_pieces(self, state: dict[str, Any]) -> dict[str, str]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç **—Å–ª–æ–≤–∞—Ä—å** –≥–æ—Ç–æ–≤—ã—Ö —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ —Ç–µ–∫—Å—Ç–∞.
        –ö–ª—é—á–∏ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –µ—Å—Ç—å.

        keys:
            warehouses  ‚Äì ¬´üìç –ê–ª–º–∞—Ç—ã ‚Ä¶¬ª
            boxes       ‚Äì ¬´‚ñ´Ô∏è –ö–æ—Ä–æ–±–∞ ‚Ä¶¬ª
            coef        ‚Äì ¬´–ë–µ—Å–ø–ª–∞—Ç–Ω–æ¬ª / ¬´–î–æ xN¬ª
        """
        pieces: dict[str, str] = {'warehouses': '', 'boxes': '', 'coef': ''}

        # ‚îÄ‚îÄ 1. —Å–∫–ª–∞–¥—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        warehouses: list[dict[str, str | int]] = state.get("selected_list") or []
        if warehouses:
            pieces["warehouses"] = self.BULLET_HUBS.join(
                f"<i>{wh['name']}</i>" for wh in warehouses
            )

        # ‚îÄ‚îÄ 2. —Ç–∏–ø—ã –∫–æ—Ä–æ–±–æ–∫ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        box_codes: list = state.get("box_type") or []
        if box_codes:
            pieces["boxes"] = self.BULLET_BOXES.join(
                f"<i>{BOX_TITLES[code]}</i>" for code in box_codes
            )

        # ‚îÄ‚îÄ 3. –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        raw_coef = state.get("coefs")
        if str(raw_coef).isdigit():
            coef = int(raw_coef)
            pieces["coef"] = (
                "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ" if coef == 0 else f"–î–æ <b>x{coef}</b>"
            )

        return pieces

    @staticmethod
    def extract_grouped_task_tuples(tasks: Sequence[TaskRead]) -> list[tuple[int, list[int], int, date, date, bool]]:
        """
        –ì—Ä—É–ø–ø–∏—Ä—É–µ—Ç –∑–∞–¥–∞—á–∏ –ø–æ —Å–∫–ª–∞–¥—É (warehouse_id), –æ–ø—Ä–µ–¥–µ–ª—è—è:
        - —Å–ø–∏—Å–æ–∫ —Ç–∏–ø–æ–≤ —É–ø–∞–∫–æ–≤–∫–∏
        - –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç
        - –Ω–∞—á–∞–ª—å–Ω—É—é –∏ –∫–æ–Ω–µ—á–Ω—É—é –¥–∞—Ç—É –ø–µ—Ä–∏–æ–¥–∞
        - –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∑–∞–¥–∞—á–∏ –Ω–∞ —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É

        :return: —Å–ø–∏—Å–æ–∫ –∫–æ—Ä—Ç–µ–∂–µ–π (warehouse_id, box_type_ids, max_coef, start_date, end_date, is_active)
        """
        grouped: dict[int, set[tuple[int, int, datetime]]] = defaultdict(set)

        for task in tasks:
            grouped[task.warehouse_id].add((task.box_type_id, task.coefficient, task.date))

        today = datetime.now().date()
        result: list[tuple[int, list[int], int, date, date, bool]] = []

        for warehouse_id, entries in grouped.items():
            box_types = sorted({box_id for box_id, _, _ in entries})
            coefficients = [coef for _, coef, _ in entries]
            dates = sorted({dt.date() if isinstance(dt, datetime) else dt for _, _, dt in entries})

            if not dates:
                continue

            max_coef = max(coefficients)
            period_start = dates[0]
            period_end = dates[-1]
            is_active = period_start <= today <= period_end

            result.append((warehouse_id, box_types, max_coef, period_start, period_end, is_active))

        return result